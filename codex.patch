diff --git a/src/main/java/com/example/examplemod/server/mechanics/modules/WindMechanic.java b/src/main/java/com/example/examplemod/server/mechanics/modules/WindMechanic.java
index 61e8a098fa0e898fa6250db8a9c400192fb6c758..9ee3c2584ec009b110f75737e503156885415d60 100644
--- a/src/main/java/com/example/examplemod/server/mechanics/modules/WindMechanic.java
+++ b/src/main/java/com/example/examplemod/server/mechanics/modules/WindMechanic.java
@@ -7,50 +7,51 @@ import com.example.examplemod.network.SyncAllStatsPacket;
 import com.example.examplemod.server.mechanics.IMechanicModule;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import net.minecraft.entity.player.ServerPlayerEntity;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.world.World;
 import net.minecraft.world.biome.Biome;
 import net.minecraft.world.server.ServerWorld;
 import net.minecraftforge.fml.network.PacketDistributor;
 
 import java.util.Map;
 import java.util.Random;
 
 /**
  * Скрытая характеристика: скорость ветра (0..30 м/с).
  * Базовый ветер обновляется раз в N минут, затем учитываются шум, биом, высота и погода.
  */
 public final class WindMechanic implements IMechanicModule {
     private static final int MAX_WIND = 30;
     private static final int MIN_WIND = 0;
     private static final int MIN_STRONG_WIND = 15;
     private static final int TICKS_PER_MINUTE = 1200;
     private static final double CLEAR_NOISE_SCALE = 2.0;
     private static final double STORM_NOISE_SCALE = 3.5;
     private static final double HURRICANE_NOISE_SCALE = 5.0;
+    private static final int HURRICANE_TARGET_WIND = 20;
     private static final int HIGH_ALTITUDE_Y = 90;
     private static final int HURRICANE_BASE_WIND_THRESHOLD = 12;
 
     private final Map<World, WindState> worldStates = new Object2ObjectOpenHashMap<>();
 
     @Override
     public String id() {
         return "wind";
     }
 
     @Override
     public int playerIntervalTicks() {
         return Config.WIND_PLAYER_UPDATE_TICKS.get();
     }
 
     @Override
     public void onPlayerTick(ServerPlayerEntity player) {
         if (player.connection == null || player.hasDisconnected()) {
             return;
         }
         if (!(player.level instanceof ServerWorld)) {
             return;
         }
         ServerWorld world = (ServerWorld) player.level;
         WindState state = getOrUpdateBaseWind(world);
@@ -60,50 +61,53 @@ public final class WindMechanic implements IMechanicModule {
                 stats.setWindSpeed(windSpeed);
                 ModNetworkHandler.CHANNEL.send(
                         PacketDistributor.PLAYER.with(() -> player),
                         new SyncAllStatsPacket(stats)
                 );
             }
         });
     }
 
     private WindState getOrUpdateBaseWind(ServerWorld world) {
         WindState state = worldStates.computeIfAbsent(world, w -> new WindState());
         int tick = world.getServer().getTickCount();
         if (tick >= state.nextBaseUpdateTick) {
             state.baseWind = rollBaseWind(world);
             int intervalTicks = Math.max(1, Config.WIND_BASE_UPDATE_MINUTES.get()) * TICKS_PER_MINUTE;
             state.nextBaseUpdateTick = tick + intervalTicks;
         }
         return state;
     }
 
     private int calculateWindForPlayer(ServerPlayerEntity player, ServerWorld world, WindState state) {
         BlockPos pos = player.blockPosition();
         ChunkPos chunkPos = new ChunkPos(pos);
         double noise = perChunkNoise(world, chunkPos.x, chunkPos.z);
         WeatherType weatherType = resolveWeatherType(world, pos, state);
+        if (weatherType == WeatherType.HURRICANE) {
+            return HURRICANE_TARGET_WIND;
+        }
         double noiseScale = resolveNoiseScale(weatherType);
         double wind = state.baseWind + noise * noiseScale;
 
         wind *= biomeMultiplier(world.getBiome(pos));
         wind *= heightMultiplier(pos.getY());
         wind *= weatherMultiplier(weatherType);
 
         if (!world.isDay()) {
             wind *= 0.9;
         }
 
         int rounded = (int) Math.round(wind);
         int minimum = minimumWindForConditions(world, pos, weatherType);
         return clampWind(Math.max(minimum, rounded));
     }
 
     private int rollBaseWind(ServerWorld world) {
         Random rand = new Random(world.getSeed() ^ world.getGameTime());
         int min = 3;
         int max = 9;
         if (world.isRaining()) {
             min = 6;
             max = 14;
         }
         if (world.isThundering()) {
