diff --git a/src/main/java/com/example/examplemod/server/mechanics/modules/HurricaneWeatherMechanic.java b/src/main/java/com/example/examplemod/server/mechanics/modules/HurricaneWeatherMechanic.java
index 9026e878bd8d949474b3296990d4a7c5ef45e02a..fcd10096652658ae71c2f304e566b4a123def3c0 100644
--- a/src/main/java/com/example/examplemod/server/mechanics/modules/HurricaneWeatherMechanic.java
+++ b/src/main/java/com/example/examplemod/server/mechanics/modules/HurricaneWeatherMechanic.java
@@ -108,51 +108,51 @@ public final class HurricaneWeatherMechanic implements IMechanicModule {
     private int rollHurricaneDuration(Random random) {
         return random.nextInt((MAX_HURRICANE_DURATION - MIN_HURRICANE_DURATION) + 1) + MIN_HURRICANE_DURATION;
     }
 
     public static boolean isHurricaneActive(ServerWorld world) {
         return HURRICANE_STATES.containsKey(world);
     }
 
     private int destroyTreesNearPlayers(ServerWorld world, int remainingBreaks) {
         List<ServerPlayerEntity> players = world.getServer().getPlayerList().getPlayers();
         if (players.isEmpty()) {
             return 0;
         }
 
         int destroyed = 0;
         for (ServerPlayerEntity player : players) {
             if (destroyed >= remainingBreaks) {
                 break;
             }
             BlockPos origin = player.blockPosition();
 
             for (int attempt = 0; attempt < TREE_SCAN_ATTEMPTS; attempt++) {
                 int x = origin.getX() + world.random.nextInt(BLOCK_RADIUS * 2 + 1) - BLOCK_RADIUS;
                 int z = origin.getZ() + world.random.nextInt(BLOCK_RADIUS * 2 + 1) - BLOCK_RADIUS;
                 int topY = world.getHeight(Heightmap.Type.MOTION_BLOCKING, x, z);
-                int minY = Math.max(world.getMinBuildHeight(), topY - TREE_SCAN_DEPTH);
+                int minY = Math.max(0, topY - TREE_SCAN_DEPTH);
 
                 BlockPos.Mutable pos = new BlockPos.Mutable(x, topY, z);
                 for (int y = topY; y >= minY; y--) {
                     pos.set(x, y, z);
                     if (world.getBlockState(pos).is(BlockTags.LOGS)) {
                         if (destroyTreeAt(world, pos.immutable())) {
                             destroyed++;
                         }
                         attempt = TREE_SCAN_ATTEMPTS;
                         break;
                     }
                 }
             }
         }
 
         return destroyed;
     }
 
     private boolean destroyTreeAt(ServerWorld world, BlockPos start) {
         ArrayDeque<BlockPos> queue = new ArrayDeque<>();
         ObjectOpenHashSet<BlockPos> visited = new ObjectOpenHashSet<>();
         queue.add(start);
         visited.add(start);
 
         int destroyed = 0;
