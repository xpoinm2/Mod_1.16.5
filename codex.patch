diff --git a/src/main/java/com/example/examplemod/tileentity/PechugaTileEntity.java b/src/main/java/com/example/examplemod/tileentity/PechugaTileEntity.java
index d0ea269c0580007c01d63a7d3d7ed771b9c21445..1231a3ea0e7cc2e7feeb0494edf9937ad7dcf096 100644
--- a/src/main/java/com/example/examplemod/tileentity/PechugaTileEntity.java
+++ b/src/main/java/com/example/examplemod/tileentity/PechugaTileEntity.java
@@ -50,51 +50,51 @@ public class PechugaTileEntity extends LockableTileEntity implements ITickableTi
     private final int[] slotCookTimes = new int[GRID_SLOT_COUNT];
     private final int[] slotCookingStages = new int[GRID_SLOT_COUNT];
 
     private int heat;
     private int heatingTicks;
     private int cookProgress;
     private int cookProgressTotal = COOK_TIME_TOTAL;
     private int coolingTicks;
 
     private final IIntArray dataAccess = new IIntArray() {
         @Override
         public int get(int index) {
             switch (index) {
                 case 0: return heat;
                 case 1: return heatingTicks;
                 case 2: return cookProgress;
                 case 3: return cookProgressTotal;
                 default: return 0;
             }
         }
 
         @Override
         public void set(int index, int value) {
             switch (index) {
                 case 0: heat = Math.max(0, Math.min(MAX_HEAT, value)); break;
-                case 1: heatingTicks = Math.max(0, Math.min(CONSUMPTION_INTERVAL_TICKS, value)); break;
+                case 1: heatingTicks = Math.max(0, Math.min(getHeatingIntervalTicks(), value)); break;
                 case 2: cookProgress = value; break;
                 case 3: cookProgressTotal = Math.max(1, value); break;
             }
         }
 
         @Override
         public int getCount() { return 4; }
     };
 
     public PechugaTileEntity() {
         super(ModTileEntities.PECHUGA.get());
     }
 
     @Override
     public void tick() {
         if (level == null || level.isClientSide) {
             return;
         }
 
         // Check if the multiblock structure is still intact
         if (!isMultiblockIntact()) {
             if (heat > 0) {
                 heat = 0;
                 heatingTicks = 0;
                 coolingTicks = 0;
@@ -102,56 +102,57 @@ public class PechugaTileEntity extends LockableTileEntity implements ITickableTi
                 setChanged();
                 level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
             }
             return;
         }
 
         boolean changed = false;
 
         if (heat > 0) {
             coolingTicks++;
             if (coolingTicks >= COOLING_INTERVAL_TICKS) {
                 coolingTicks = 0;
                 int newHeat = Math.max(0, heat - COOLING_AMOUNT);
                 if (newHeat != heat) {
                     heat = newHeat;
                     changed = true;
                 }
             }
         } else if (coolingTicks != 0) {
             coolingTicks = 0;
         }
 
         ItemStack fuelStack = items.get(FUEL_SLOT);
         boolean hasInput = hasSmeltableInput();
         int specificHeat = getSpecificHeat(fuelStack);
+        int heatingInterval = getHeatingIntervalTicks();
 
         if (heat < MAX_HEAT && specificHeat > 0) {
-            if (heatingTicks < CONSUMPTION_INTERVAL_TICKS) {
+            if (heatingTicks < heatingInterval) {
                 heatingTicks++;
             }
-            if (heatingTicks >= CONSUMPTION_INTERVAL_TICKS) {
+            if (heatingTicks >= heatingInterval) {
                 heatingTicks = 0;
                 ItemStack containerItem = fuelStack.getContainerItem();
                 fuelStack.shrink(1);
                 if (fuelStack.isEmpty()) {
                     items.set(FUEL_SLOT, containerItem);
                 }
                 int heatGain = Math.max(1, specificHeat / SPECIFIC_HEAT_PER_HEAT_UNIT);
                 int newHeat = Math.min(MAX_HEAT, heat + heatGain);
                 if (newHeat != heat) {
                     heat = newHeat;
                     changed = true;
                 }
                 changed = true;
             }
         } else if (heatingTicks != 0) {
             heatingTicks = 0;
             changed = true;
         }
 
         if (heat >= MIN_HEAT_FOR_SMELTING && hasInput) {
             if (processCookingCycle()) {
                 changed = true;
             }
         } else {
             if (!hasInput) {
@@ -660,51 +661,51 @@ public class PechugaTileEntity extends LockableTileEntity implements ITickableTi
                 (double) worldPosition.getY() + 0.5D,
                 (double) worldPosition.getZ() + 0.5D) <= 64.0D;
     }
 
     @Override
     public void clearContent() {
         for (int i = 0; i < items.size(); ++i) {
             items.set(i, ItemStack.EMPTY);
         }
         resetCookingProgress();
         heat = 0;
         heatingTicks = 0;
         coolingTicks = 0;
         setChanged();
     }
 
     @Override
     public void load(BlockState state, CompoundNBT nbt) {
         super.load(state, nbt);
         for (int i = 0; i < items.size(); ++i) {
             items.set(i, ItemStack.EMPTY);
         }
         ItemStackHelper.loadAllItems(nbt, items);
         enforceInputStackLimits();
         heat = Math.max(0, Math.min(MAX_HEAT, nbt.getInt("Heat")));
-        heatingTicks = Math.max(0, Math.min(CONSUMPTION_INTERVAL_TICKS, nbt.getInt("HeatingTicks")));
+        heatingTicks = Math.max(0, Math.min(getHeatingIntervalTicks(), nbt.getInt("HeatingTicks")));
         coolingTicks = Math.max(0, Math.min(COOLING_INTERVAL_TICKS, nbt.getInt("CoolingTicks")));
         int[] savedCookTimes = nbt.getIntArray("SlotCookTimes");
         if (savedCookTimes.length == GRID_SLOT_COUNT) {
             System.arraycopy(savedCookTimes, 0, slotCookTimes, 0, GRID_SLOT_COUNT);
         } else {
             for (int i = 0; i < GRID_SLOT_COUNT; ++i) {
                 slotCookTimes[i] = 0;
             }
         }
         int[] savedCookingStages = nbt.getIntArray("SlotCookingStages");
         if (savedCookingStages.length == GRID_SLOT_COUNT) {
             System.arraycopy(savedCookingStages, 0, slotCookingStages, 0, GRID_SLOT_COUNT);
         } else {
             for (int i = 0; i < GRID_SLOT_COUNT; ++i) {
                 slotCookingStages[i] = 0;
             }
         }
         cookProgress = nbt.contains("CookProgress") ? nbt.getInt("CookProgress") : 0;
         cookProgressTotal = nbt.contains("CookProgressTotal")
                 ? Math.max(1, nbt.getInt("CookProgressTotal"))
                 : COOK_TIME_TOTAL;
         updateCookProgress();
     }
 
     @Override
@@ -739,26 +740,84 @@ public class PechugaTileEntity extends LockableTileEntity implements ITickableTi
 
     @Nullable
     @Override
     public Container createMenu(int id, PlayerInventory playerInventory) {
         return new com.example.examplemod.container.PechugaContainer(id, playerInventory, this);
     }
 
     private int getSpecificHeat(ItemStack stack) {
         if (stack.isEmpty()) {
             return 0;
         }
         if (stack.getItem() == Items.COAL || stack.getItem() == Items.CHARCOAL) {
             return 1600;
         }
         if (stack.getItem().is(ItemTags.PLANKS)) {
             return 160;
         }
         if (stack.getItem().is(ItemTags.LOGS)) {
             return 320;
         }
         if (stack.getItem() == Items.STICK) {
             return 80;
         }
         return 0;
     }
+
+    private int getHeatingIntervalTicks() {
+        return isColdBiome() ? CONSUMPTION_INTERVAL_TICKS * 2 : CONSUMPTION_INTERVAL_TICKS;
+    }
+
+    private boolean isColdBiome() {
+        if (level == null) {
+            return false;
+        }
+        return getBiomeTemperature(level, worldPosition) < 1;
+    }
+
+    /**
+     * Получает температуру биома в указанной позиции.
+     * Использует ту же логику, что и BiomeTemperatureCache для игроков.
+     */
+    private int getBiomeTemperature(net.minecraft.world.World world, BlockPos pos) {
+        if (world.dimension() == net.minecraft.world.World.NETHER) return 666;
+        if (world.dimension() == net.minecraft.world.World.END) return -666;
+
+        net.minecraft.world.biome.Biome biome = world.getBiome(pos);
+        net.minecraft.world.biome.Biome.Category cat = biome.getBiomeCategory();
+
+        switch (cat) {
+            case PLAINS:
+                return 23;
+            case DESERT:
+            case MESA:
+                return 37;
+            case SAVANNA:
+                return 30;
+            case FOREST:
+                return 17;
+            case JUNGLE:
+                return 30;
+            case SWAMP:
+                return -13;
+            case TAIGA:
+                return -25;
+            case EXTREME_HILLS:
+                return -10;
+            case ICY:
+                return -40;
+            case BEACH:
+            case RIVER:
+                return 10;
+            case OCEAN:
+                return 6;
+            case MUSHROOM:
+                return 0;
+            case NETHER:
+                return 666;
+            case THEEND:
+                return -666;
+            default:
+                return 0;
+        }
+    }
 }
