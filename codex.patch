 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/src/main/java/com/example/examplemod/server/mechanics/modules/HurricaneWeatherMechanic.java b/src/main/java/com/example/examplemod/server/mechanics/modules/HurricaneWeatherMechanic.java
index 0cc8e8a0f6f6ca6ec676a3f2fe068c77b1a980ed..799f96c129ecdb45083dcd01d28ba9163a115923 100644
--- a/src/main/java/com/example/examplemod/server/mechanics/modules/HurricaneWeatherMechanic.java
+++ b/src/main/java/com/example/examplemod/server/mechanics/modules/HurricaneWeatherMechanic.java
@@ -40,114 +40,161 @@ public final class HurricaneWeatherMechanic implements IMechanicModule {
     private static final Map<ServerWorld, HurricaneState> HURRICANE_STATES = new Object2ObjectOpenHashMap<>();
 
     @Override
     public String id() {
         return "hurricane_weather";
     }
 
     @Override
     public boolean enableRegisterCommands() {
         return true;
     }
 
     @Override
     public boolean enableWorldTick() {
         return true;
     }
 
     @Override
     public void onRegisterCommands(RegisterCommandsEvent event) {
         event.getDispatcher().register(
                 Commands.literal("hurricane")
                         .requires(source -> source.hasPermission(2))
                         .executes(this::startHurricane)
                         .then(Commands.literal("start")
                                 .executes(this::startHurricane))
+                        .then(Commands.literal("on")
+                                .executes(this::enableHurricaneWeather))
+                        .then(Commands.literal("enable")
+                                .executes(this::enableHurricaneWeather))
+                        .then(Commands.literal("off")
+                                .executes(this::disableHurricaneWeather))
+                        .then(Commands.literal("disable")
+                                .executes(this::disableHurricaneWeather))
                         .then(Commands.literal("stop")
                                 .executes(this::stopHurricane))
         );
     }
 
     @Override
     public void onWorldTick(TickEvent.WorldTickEvent event) {
         if (event.phase != TickEvent.Phase.END) {
             return;
         }
         if (!(event.world instanceof ServerWorld)) {
             return;
         }
 
         ServerWorld world = (ServerWorld) event.world;
         HurricaneWeatherData data = HurricaneWeatherData.get(world);
+        if (!data.isEnabled()) {
+            if (data.isActive() || HURRICANE_STATES.containsKey(world)) {
+                clearHurricane(world, data);
+            }
+            return;
+        }
+
         HurricaneState state = HURRICANE_STATES.get(world);
         if (state == null) {
             if (data.isActive()) {
                 long tick = world.getGameTime();
                 if (tick >= data.getEndTick()) {
                     data.clear();
                     return;
                 }
                 state = HurricaneState.fromData(data);
                 HURRICANE_STATES.put(world, state);
                 sendHurricaneState(world, true);
             } else {
                 return;
             }
         }
 
         long tick = world.getGameTime();
         if (tick >= state.endTick) {
             clearHurricane(world, data);
             return;
         }
 
+        clearVanillaWeather(world);
+
         if (state.breaksRemaining <= 0 || tick < state.nextBreakTick) {
             return;
         }
 
         int destroyed = destroyTreesNearPlayers(world, state.breaksRemaining);
         if (destroyed > 0) {
             state.breaksRemaining -= destroyed;
         }
         state.scheduleNextBreak(tick);
         data.updateProgress(state.breaksRemaining, state.nextBreakTick);
     }
 
     private int startHurricane(CommandContext<CommandSource> context) {
         CommandSource source = context.getSource();
         ServerWorld world = source.getLevel();
         HurricaneWeatherData data = HurricaneWeatherData.get(world);
+        if (!data.isEnabled()) {
+            source.sendFailure(new StringTextComponent("Hurricane weather from mod is disabled. Use /hurricane on."));
+            return 0;
+        }
         Random random = world.getRandom();
         int duration = rollHurricaneDuration(random);
         HurricaneState state = new HurricaneState(world.getGameTime(), duration, random);
         HURRICANE_STATES.put(world, state);
         data.start(state.endTick, state.totalBreaks, state.breaksRemaining, state.nextBreakTick);
+        clearVanillaWeather(world);
         sendHurricaneState(world, true);
         source.sendSuccess(new StringTextComponent("Hurricane started for " + duration + " ticks."), true);
         return 1;
     }
 
+    private int enableHurricaneWeather(CommandContext<CommandSource> context) {
+        CommandSource source = context.getSource();
+        ServerWorld world = source.getLevel();
+        HurricaneWeatherData data = HurricaneWeatherData.get(world);
+        if (data.isEnabled()) {
+            source.sendSuccess(new StringTextComponent("Hurricane weather from mod is already enabled."), false);
+            return 1;
+        }
+        data.setEnabled(true);
+        source.sendSuccess(new StringTextComponent("Hurricane weather from mod enabled."), true);
+        return 1;
+    }
+
+    private int disableHurricaneWeather(CommandContext<CommandSource> context) {
+        CommandSource source = context.getSource();
+        ServerWorld world = source.getLevel();
+        HurricaneWeatherData data = HurricaneWeatherData.get(world);
+        data.setEnabled(false);
+        if (data.isActive() || HURRICANE_STATES.containsKey(world)) {
+            clearHurricane(world, data);
+        }
+        source.sendSuccess(new StringTextComponent("Hurricane weather from mod disabled."), true);
+        return 1;
+    }
+
     private int stopHurricane(CommandContext<CommandSource> context) {
         CommandSource source = context.getSource();
         ServerWorld world = source.getLevel();
         HurricaneWeatherData data = HurricaneWeatherData.get(world);
         if (!HURRICANE_STATES.containsKey(world) && !data.isActive()) {
             source.sendFailure(new StringTextComponent("No active hurricane to stop."));
             return 0;
         }
         clearHurricane(world, data);
         source.sendSuccess(new StringTextComponent("Hurricane stopped."), true);
         return 1;
     }
 
     private int rollHurricaneDuration(Random random) {
         return random.nextInt((MAX_HURRICANE_DURATION - MIN_HURRICANE_DURATION) + 1) + MIN_HURRICANE_DURATION;
     }
 
     public static boolean isHurricaneActive(ServerWorld world) {
         return HURRICANE_STATES.containsKey(world);
     }
 
     @Override
     public void onPlayerLogin(ServerPlayerEntity player) {
         ServerWorld world = player.getLevel();
         if (isHurricaneActive(world) || HurricaneWeatherData.get(world).isActive()) {
@@ -261,26 +308,30 @@ public final class HurricaneWeatherMechanic implements IMechanicModule {
             if (breaksRemaining <= 0) {
                 nextBreakTick = endTick;
                 return;
             }
             long remainingTicks = Math.max(1, endTick - currentTick);
             long interval = Math.max(1, remainingTicks / breaksRemaining);
             nextBreakTick = currentTick + interval;
         }
     }
 
     private void sendHurricaneState(ServerWorld world, boolean active) {
         for (ServerPlayerEntity player : world.getPlayers(player -> true)) {
             sendHurricaneState(player, active);
         }
     }
 
     private void sendHurricaneState(ServerPlayerEntity player, boolean active) {
         ModNetworkHandler.CHANNEL.sendTo(new HurricaneStatePacket(active), player.connection.connection, net.minecraftforge.fml.network.NetworkDirection.PLAY_TO_CLIENT);
     }
 
     private void clearHurricane(ServerWorld world, HurricaneWeatherData data) {
         sendHurricaneState(world, false);
         HURRICANE_STATES.remove(world);
         data.clear();
     }
+
+    private void clearVanillaWeather(ServerWorld world) {
+        world.setWeatherParameters(6000, 0, false, false);
+    }
 }
 
EOF
)